# -*- coding: utf-8 -*-
"""creacion_de_certificado.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sItaIAy2uqquATfTI4oAJ69N735qtqJw
"""

!pip3 install cryptography

import os
from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.x509 import oid
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.asymmetric import padding
import hashlib

import datetime


one_day = datetime.timedelta(1, 0, 0)

def generate_private_key(key_size=2048):
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=key_size,
        backend=default_backend()
    )
    return private_key

def get_public_key(certificate):
    public_key = certificate.public_key()
    return public_key

def generate_certificate(name):
    subject = x509.Name([
        x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, name),
    ])
    builder = x509.CertificateBuilder()
    builder = builder.subject_name(subject)
    builder = builder.issuer_name(x509.Name([
         x509.NameAttribute(NameOID.COMMON_NAME, u'Centro Control #'),
    ]))
    builder = builder.not_valid_before(datetime.datetime.today() - one_day)
    builder = builder.not_valid_after(datetime.datetime.today())
    builder = builder.serial_number(x509.random_serial_number())
    builder = builder.public_key(private_key.public_key())
    certificate = builder.sign(private_key, hashes.SHA256(), default_backend())
    return certificate

def save_certificate_to_file(certificate, file_name):
    with open(file_name, "wb") as file:
        file.write(certificate.public_bytes(serialization.Encoding.PEM))

def load_certificate_from_file(file_name):
    with open(file_name, "rb") as file:
        certificate = x509.load_pem_x509_certificate(file.read(), default_backend())
    return certificate


def sign_certificate(certificate, private_key):
    signature = private_key.sign(
        certificate.tbs_certificate_bytes,
        padding.PKCS1v15(),
        hashes.SHA256()
    )
    return signature

def verify_certificate(certificate, name, date,public_key,signature, tolerance_days=7):
    if certificate.subject.get_attributes_for_oid(oid.NameOID.COMMON_NAME)[0].value != name:
        return "The certificate is invalid. False name"
    
    not_before = certificate.not_valid_before
    not_after = certificate.not_valid_after
    if not (not_before <= date <= not_after):
        tolerance = datetime.timedelta(days=tolerance_days)
        if not (not_before - tolerance <= date <= not_after + tolerance):
            return "The certificate is invalid. False date"
    
    try:
        public_key.verify(
            signature,
            certificate.tbs_certificate_bytes,
            padding.PKCS1v15(),
            hashes.SHA256()
        )
        print("The certificate is valid.")
    except Exception:
        return "The certificate is invalid"

# Ejemplo de uso
date = datetime.datetime.today()
private_key = generate_private_key()
name = "Auditor_1"
certificate = generate_certificate(f'{name}')
public_key = get_public_key(certificate)
file_name = f'{name}.crt'
save_certificate_to_file(certificate, file_name)

date = datetime.datetime.today()
name = "Auditor_1"
file_name = f'{name}.crt'
saved_certificate = load_certificate_from_file(file_name)
signature = sign_certificate(saved_certificate,private_key)
#Verificamos el certificado tomando el certificado, la fecha, la llave publica y la firma
verify_certificate(saved_certificate, f'{name}',date,public_key,signature)


